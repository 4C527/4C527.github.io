<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>浅析JDK源码之集合框架（七） | Jason Cheng的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="上一篇：浅析JDK源码之集合框架（六）下一篇：待定（Jason Cheng 原创，未经许可不可转载） 
HashMap类源码分析&amp;#160; &amp;#160; &amp;#160; &amp;#160;上一篇我们分析了Map接口的源码，在这一篇中我们就正式开始分析Map体系中最重要，也是广大程序员最常用的一个类：HashMap.">
<meta property="og:type" content="article">
<meta property="og:title" content="浅析JDK源码之集合框架（七）">
<meta property="og:url" content="http://yoursite.com/2016/12/05/浅析JDK源码之集合框架（七）/index.html">
<meta property="og:site_name" content="Jason Cheng的博客">
<meta property="og:description" content="上一篇：浅析JDK源码之集合框架（六）下一篇：待定（Jason Cheng 原创，未经许可不可转载） 
HashMap类源码分析&amp;#160; &amp;#160; &amp;#160; &amp;#160;上一篇我们分析了Map接口的源码，在这一篇中我们就正式开始分析Map体系中最重要，也是广大程序员最常用的一个类：HashMap.">
<meta property="og:image" content="http://ocpreuqkv.bkt.clouddn.com/blog12/2/1352093418_6990.png">
<meta property="og:updated_time" content="2016-12-08T07:37:41.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="浅析JDK源码之集合框架（七）">
<meta name="twitter:description" content="上一篇：浅析JDK源码之集合框架（六）下一篇：待定（Jason Cheng 原创，未经许可不可转载） 
HashMap类源码分析&amp;#160; &amp;#160; &amp;#160; &amp;#160;上一篇我们分析了Map接口的源码，在这一篇中我们就正式开始分析Map体系中最重要，也是广大程序员最常用的一个类：HashMap.">
<meta name="twitter:image" content="http://ocpreuqkv.bkt.clouddn.com/blog12/2/1352093418_6990.png">
  
    <link rel="alternative" href="/atom.xml" title="Jason Cheng的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="http://ocpreuqkv.bkt.clouddn.com/logosuolue.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/avatar.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Jason Cheng</a></h1>
		</hgroup>

		
		<p class="header-subtitle">吾当乘此羽葆盖车。</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tags/深度学习">深度学习</a></li>
				        
							<li><a href="/tags/leetcode">leetcode</a></li>
				        
							<li><a href="/tags/随笔">随笔</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/JDK源码/" style="font-size: 20px;">JDK源码</a> <a href="/tags/TensorFlow/" style="font-size: 20px;">TensorFlow</a> <a href="/tags/Tree/" style="font-size: 13.33px;">Tree</a> <a href="/tags/leetcode/" style="font-size: 20px;">leetcode</a> <a href="/tags/卷积神经网络/" style="font-size: 10px;">卷积神经网络</a> <a href="/tags/数据结构/" style="font-size: 20px;">数据结构</a> <a href="/tags/深度学习/" style="font-size: 20px;">深度学习</a> <a href="/tags/链表/" style="font-size: 16.67px;">链表</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">Witness me.Witness me.</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Jason Cheng</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img lazy-src="null/img/avatar.jpg" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">Jason Cheng</h1>
			</hgroup>
			
			<p class="header-subtitle">吾当乘此羽葆盖车。</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/深度学习">深度学习</a></li>
		        
					<li><a href="/tags/leetcode">leetcode</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-浅析JDK源码之集合框架（七）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/12/05/浅析JDK源码之集合框架（七）/" class="article-date">
  	<time datetime="2016-12-05T03:05:44.000Z" itemprop="datePublished">2016-12-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      浅析JDK源码之集合框架（七）
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JDK源码/">JDK源码</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://4c527.github.io/2016/12/01/%E6%B5%85%E6%9E%90JDK%E6%BA%90%E7%A0%81%E4%B9%8B%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%88%E5%85%AD%EF%BC%89/" target="_blank" rel="external">上一篇：浅析JDK源码之集合框架（六）</a><br><a href="https://4c527.github.io/2016/09/30/%E6%B5%85%E8%B0%88%E9%93%BE%E8%A1%A8%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="external">下一篇：待定</a><br>（Jason Cheng 原创，未经许可不可转载） </p>
<h1 id="HashMap类源码分析"><a href="#HashMap类源码分析" class="headerlink" title="HashMap类源码分析"></a>HashMap类源码分析</h1><p>&#160; &#160; &#160; &#160;上一篇我们分析了Map接口的源码，在这一篇中我们就正式开始分析Map体系中最重要，也是广大程序员最常用的一个类：HashMap.<a id="more"></a><br>&#160; &#160; &#160; &#160;相对之前的List体系来说的话，HashMap数据结构的实现要更为复杂一点。但实际上，如果我们了解之后，也就会觉得其实这种结构很清晰。在分析HashMap的源码之前，我们先补充一点关于哈希表的基础知识，让一些不太了解哈希表的读者也能理解（HashMap正是基于这种数据结构来实现的）：<br>&#160; &#160; &#160; &#160;散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。<br>&#160; &#160; &#160; &#160;也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。<br>&#160; &#160; &#160; &#160;这个映射函数叫做散列函数，存放记录的数组就叫做散列表。<br>&#160; &#160; &#160; &#160;给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，我们就称表M为哈希表，函数f(key)为哈希(Hash)函数。<br>&#160; &#160; &#160; &#160;也就是说，我们归纳来说，虽然被命名为哈希表，但实际上，内部的数据结构仍然是基于数组来维护的（这个说法非常笼统，只是为了便于大家理解。实际上，这个“数组”内部的实现机制有多种）。<br>&#160; &#160; &#160; &#160;只是该数组与List对比来说，它不再直接存储值，而是通过将我们存储的对象计算出一个值，这个值就是所谓的哈希值（散列码），也就是上面的概念提到的Key Value（关键码值），然后数组通过维护该关键码值，从而避免了速度缓慢的线性查询，从而提高数据的访问速度。<br>&#160; &#160; &#160; &#160;基础知识补充完了，接下来的这一篇我们就开始分析真正的HashMap源码。（代码基于JDK1.8）<br>&#160; &#160; &#160; &#160;为了让大家对集合框架中的继承体系有一个更直观的认识，这里继续放上集合的结构图：</p>
<p><center><img src="http://ocpreuqkv.bkt.clouddn.com/blog12/2/1352093418_6990.png" width="70%"></center><br>&#160; &#160; &#160; &#160;为了分析过程中思路清晰，我们同样先从该容器类的继承结构说起。打开HashMap的源码，首先看到这样的类声明：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></div><div class="line">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></div></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;可以看到，继承结构上，HashMap继承了AbstractMap类，同时实现了Map<k,v>接口。<br>&#160; &#160; &#160; &#160;好，到了正式的代码部分。首先让我们来看看HashMap的几个重要成员变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></div><div class="line"><span class="comment">//HashMap的初始容量</span></div><div class="line"><span class="comment">//为什么不直接写成16？HashMap的作者是想用这种写法告诉你只能是2的幂</span></div><div class="line"><span class="comment">//小结：HashMap的初始容量是16，而且容量只能是2的幂，每次扩容时都是变成原来的2倍</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</div><div class="line"><span class="comment">//HashMap能允许的最大容量</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</div><div class="line"><span class="comment">//负载因子是指哈希表在多满时扩容的百分比比例</span></div><div class="line"><span class="comment">//当哈希表的数据个数超过负载因子和当前容量的乘积时</span></div><div class="line"><span class="comment">//哈希表要再做一次哈希（重建内部数据结构），哈希表每次扩容为原来的2倍</span></div><div class="line"><span class="comment">//负载因子的默认值是0.75， 它平衡了时间和空间复杂度</span></div><div class="line"><span class="comment">//负载因子越大会降低空间复杂度，但是会增加每次读取／查询的成本</span></div><div class="line"><span class="comment">//默认的负载因子是0.75f， 16*0.75=12</span></div><div class="line"><span class="comment">//即默认的HashMap实例在插入第13个数据时，会扩容为32</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</div><div class="line"><span class="comment">//注这是JDK1.8对HashMap的优化</span></div><div class="line"><span class="comment">//哈希碰撞后的链表上达到8个节点时要将链表重构为红黑树</span></div><div class="line"><span class="comment">//查询的时间复杂度变为O(logN)</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</div><div class="line"></div><div class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</div><div class="line"><span class="comment">//HashMap的桶</span></div><div class="line"><span class="comment">//如果没有哈希碰撞，HashMap就是数组，数组的查询时间复杂度是O(1)，所以HashMap理想时间复杂度是O(1)</span></div><div class="line"><span class="comment">//如果所有数据都在同一个下标位置，即N个数据组成链表，时间复杂度为O(n)，所以HashMap的最坏时间复杂度为O(n)</span></div><div class="line"><span class="comment">//如果链表达到8个元素时重构为红黑树，而红黑树的查询时间复杂度为O(logN), 所以这时HashMap的时间复杂度为O(logN)</span></div><div class="line"></div><div class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</div><div class="line"><span class="comment">//HashMap所有的值，因为用了Set， 所以HashMap不会有key、value都相同的entry</span></div><div class="line"></div><div class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</div><div class="line"><span class="comment">//存放元素的个数 </span></div><div class="line"></div><div class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</div><div class="line"><span class="comment">//被修改的次数</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> threshold;</div><div class="line"><span class="comment">//临界值 当实际大小(容量*填充比)超过临界值时，会进行扩容</span></div><div class="line"></div><div class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</div><div class="line"><span class="comment">//负载因子</span></div></pre></td></tr></table></figure></k,v></p>
<p>&#160; &#160; &#160; &#160;分析完了HashMap的几个重要成员变量，接下来我们再来分析HashMap中几个重要的数据结构，分析完后，我们对HashMap的内部机制就有了一个基础的理解，首先是HashMap中链表的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">//Node是单向链表，它实现了Map.Entry接口  </span></div><div class="line">    </div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</div><div class="line">    <span class="keyword">final</span> K key;</div><div class="line">    V value;</div><div class="line">    Node&lt;K,V&gt; next;</div><div class="line">   </div><div class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</div><div class="line">        <span class="keyword">this</span>.hash = hash;</div><div class="line">        <span class="keyword">this</span>.key = key;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">        <span class="keyword">this</span>.next = next;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//构造函数，传入参数为：hash值，键，值，next节点 </span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</div><div class="line">        V oldValue = value;</div><div class="line">        value = newValue;</div><div class="line">        <span class="keyword">return</span> oldValue;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//重设置节点值，返回旧值</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</div><div class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</div><div class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</div><div class="line">                Objects.equals(value, e.getValue()))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//判断两个node是否相等,若key和value都相等，返回true</span></div><div class="line">    <span class="comment">//可以与自身比较为true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;接着是HashMap中红黑树的源码：     </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></div><div class="line">    <span class="comment">//红黑树父节点</span></div><div class="line">    </div><div class="line">    TreeNode&lt;K,V&gt; left;</div><div class="line">    <span class="comment">//左节点</span></div><div class="line">    </div><div class="line">    TreeNode&lt;K,V&gt; right;</div><div class="line">    <span class="comment">//右节点</span></div><div class="line">    </div><div class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></div><div class="line">    <span class="keyword">boolean</span> red;</div><div class="line">    <span class="comment">//颜色属性</span></div><div class="line">    </div><div class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</div><div class="line">        <span class="keyword">super</span>(hash, key, val, next);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns root of tree containing this node.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="keyword">this</span>, p;;) &#123;</div><div class="line">            <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">return</span> r;</div><div class="line">            r = p;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//返回当前节点的根节点</span></div><div class="line">    </div><div class="line">    <span class="comment">//TreeNode类还有其他很多函数，这里略去</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;接下来是HashMap内部用于存储链表／红黑树的数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</div><div class="line"><span class="comment">//存储（位桶）的数组</span></div></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;分析完了以上3个数据结构，只要有一点数据结构基础的人，都可以大致联想到HashMap的实现了。首先有一个每个元素都是链表（这一点描述并不十分准确）的数组，当添加一个元素（key-value）时，就首先计算元素key的hash值，以此确定插入数组中的位置，但是可能存在同一hash值的元素已经被放在数组同一位置了，这时就添加到同一hash值的元素的后面，他们在数组的同一位置，但是形成了链表，所以说数组存放的是链表。而当链表长度太长时，链表就转换为红黑树，这是为了效率上的考虑。<br>&#160; &#160; &#160; &#160;在之前的版本JDK1.6中，HashMap采用位桶+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。所以在JDK1.8中引入了红黑树，HashMap采用位桶+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。</p>
<p>&#160; &#160; &#160; &#160;第一种构造器，可以接受一个int型的参数，它是用来指定ArrayList内部的数组elementData的初始大小的。如果该参数传入的值小于0，则会抛出一个IllegalArgumentException异常。<br>&#160; &#160; &#160; &#160;第二种构造器，直接将内部数组elementData初始化为空数组。在JDK1.8之前，ArrayList的第二种构造器有一些不同，它直接就在内部调用第一种构造器，并将大小参数值指定为10。JDK1.8可能是出于降低空间复杂度的考虑，改进了第二种构造器的写法。<br>&#160; &#160; &#160; &#160;第三种构造器，接收Collection接口类型的参数。然后通过调用其toArray方法，将其转换为数组，赋值给内部的elementData。如果elementData数组的大小不为0的话，则将element设置为大小为，否则仍将elementData设为空数组。<br>&#160; &#160; &#160; &#160;看完了构造器部分，接下来按照ArrayList常见操作来分析源码。<br>&#160; &#160; &#160; &#160;首先是插入元素。我们来分析一下有关插入操作的一系列代码：</p>
<p>&#160; &#160; &#160; &#160;这段代码的目的，（以及接下来的一些关于Capacity的代码），都是为了增加此ArrayList中元素的容量，以确保它至少能够容纳最小容量参数所指定的元素数。也就是说，该方法就是用来修改容器的大小的。该段代码的大意是为了使采用ArrayList()构造函数进行构造的对象最大扩容参数不能小于DEFAULT_CAPACITY，即10，否则不扩容；使采用ArrayList(int initialCapacity)构造函数进行构造的最大扩容参数不能小于0，否则不扩容。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</div><div class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ensureExplicitCapacity(minCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这段代码的大意是确保使采用ArrayList()构造函数进行构造的对象最小扩容量为DEFAULT_CAPACITY,即10和用户传的扩容参数minCapacity中较大值，即最小扩容量为10.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    modCount++;<span class="comment">//记录ArrayList被修改的次数</span></div><div class="line"></div><div class="line">    <span class="comment">// overflow-conscious code</span></div><div class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</div><div class="line">        grow(minCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;modCount这个变量继承自AbstractList类当中的一个成员变量。而它的作用则是：记录已从结构上修改此列表的次数。从结构上修改是指更改列表的大小，或者打乱列表等。所以，很自然的，当我们每次扩容的时候，自然也就会改变容器的现有结构。故让该变量自增。如果扩容参数不小于原来容器大小，则视为合法，调用grow(minCapacity)进行扩容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</div><div class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</div><div class="line">        Integer.MAX_VALUE :</div><div class="line">        MAX_ARRAY_SIZE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这段代码主要是为了使在扩容参数到达最大边界时确保不会越界。如果扩容参数小于0，则报OutOfMemoryError()错误，如果大于规定的最大容量，则返回Integer.MAX_VALUE，如果不大于，则返回规定的最大容量MAX_ARRAY_SIZE。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;     </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">// overflow-conscious code</span></div><div class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">        newCapacity = minCapacity;</div><div class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</div><div class="line">        newCapacity = hugeCapacity(minCapacity);</div><div class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></div><div class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;grow(minCapacity)是真正给ArrayList容器扩容的函数。<br>&#160; &#160; &#160; &#160;首先，int oldCapacity = elementData.length;这行代码通过内部数组的现有长度得到容器的现有容量。<br>&#160; &#160; &#160; &#160;然后，会通过int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);来计算初步得到一个新的容量值（即旧容量的1.5倍，注意这个右移操作，比直接除以2效率高）。如果计算得到的容量值小于我们传入的指定的新的容量值，那么就使用我们传入的容量值。否则就使用计算得到的值作为新的容量值。<br>&#160; &#160; &#160; &#160;那么，为什么有一个传入的指定值minCapacity了，还额外做了这个计算newCapacity的运算呢？<br>&#160; &#160; &#160; &#160;其实不难想象到，这样做是为了提高程序效率。假设我们通过构造函数构建了一个ArrayList（10），那么容器内部就有了一个大小为10的初始数组了。这个时候，我们开始循环的对容器进行插入元素操作。不难想象当执行到第11次add的时候，就需要扩充数组长度了。那么根据后面add方法自身的定义，这里传入的minCapacity值就是11.而通过计算得到的newCapacity = 10 ＋ 10 &gt;&gt; 2 = 15.到这里就很容易看到好处了，因为如果不进行上面的运算：那么当超过数组的初始长度后，每次add都需要执行数组扩充的工作。而因为newCapacity的计算，数组直接扩容到15，在第11次插入直到执行到第15次插入，都不需要进行扩充了。<br>&#160; &#160; &#160; &#160;然后，计算得到的newCapacity如果超过了规定的最大容量，则赋值为上面的hugeCapacity(int minCapacity)。<br>&#160; &#160; &#160; &#160;最后，根据得到的最新的newCapacity更新elementData，用Arrays工具类中的copyOf函数将elementData扩容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">    elementData[size++] = e;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">    rangeCheckForAdd(index);</div><div class="line"></div><div class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</div><div class="line">                     size - index);</div><div class="line">    elementData[index] = element;</div><div class="line">    size++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;分析了以上一系列与扩容相关的函数之后，我们终于可以谈到add(E e)方法了。首先调用扩容函数ensureCapacityInternal(size + 1);确保内部数组完成扩充，之后的代码是简单的elementData[size++] = e;即在数组完成扩充后，进行元素插入。同时在完成添加过后，将代表容器内当前存放的元素量的变量size的值进行一次自增。<br>&#160; &#160; &#160; &#160;然后是通过下标来插入元素的插入函数add(int index, E element)，首先有一个合法性判断，index大于容器容量或者小于0都将抛出越界异常。<br>&#160; &#160; &#160; &#160;插入元素具体过程如下：将原本数组中下标index开始的元素按指定位数（根据要插入的元素个数决定）进行位移，用新元素替换原index下标上的元素，这样，插入元素的操作就完成了。而这其实也解释了：为什么相对于LinkedList来说，ArrayList在执行元素的增删操作时，效率低很多。这是因为在数组结构下，每当涉及到在容器中间增删元素，就会有大量的元素发生位移。<br>&#160; &#160; &#160; &#160;另外，对于插入元素的方法来说，还有另外两个，它们分别是：<br>addAll(Collection&lt; ? extends E &gt; c) 以及addAll(int index, Collection&lt; ? extends E &gt; c)。在这里，就不再分析它们的源码了，跟之前的2个add操作类似，它们的核心思想都是一样的：都是先判断是否需要对现有的数组进行扩充；然后根据具体情况（插入单个元素还是多个，在中间插入还是在后端插入）进行元素的插入保存工作。<br>&#160; &#160; &#160; &#160;经过以上一系列分析，ArrayList容器的插入部分代码就分析完了。<br>&#160; &#160; &#160; &#160;接下来是删除元素。我们来分析一下有关删除操作的一系列代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (index &gt;= size)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    rangeCheck(index);</div><div class="line"></div><div class="line">    modCount++;</div><div class="line">    E oldValue = elementData(index);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</div><div class="line">                         numMoved);</div><div class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;首先，remove(int index)执行了一个名为rangeCheck的方法调用，与add方法类似，这是做容器范围检查的工作的。它所做的工作很简单：对传入的角标进行判断，如果它大于或等于容器的实际存放量，则报告越界异常。<br>&#160; &#160; &#160; &#160;接下来的一行代码，我们已经很熟悉了。删除元素也会改变容器的现有结构，所以让modCount自增。<br>&#160; &#160; &#160; &#160;然后，是根据该角标从内部维护的elementData数组中，将该下标对应的元素取出。<br>&#160; &#160; &#160; &#160;再然后的两行代码就是删除元素的关键，其思想与插入元素时是一致的。仍然是通过arrayCopy执行位移拷贝。不同在于：删除元素是将源数组index+1开始的元素复制到目标数组的index处。也就是说，与添加相反，是在做元素左移拷贝。<br>&#160; &#160; &#160; &#160;接下来的一行代码则是elementData[–-size]，它的将数组最后的一个元素设置为null。注释// Let gc do its work则说明，我们将元素值设为null之后，由gc堆负责废弃对象的清理。<br>&#160; &#160; &#160; &#160;最后，返回被删除的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</div><div class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</div><div class="line">                fastRemove(index);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</div><div class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</div><div class="line">                fastRemove(index);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</div><div class="line">                         numMoved);</div><div class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;remove(Object o)这个函数同样不复杂，它本质上就是对数组做了遍历，当发现有与我们传入的对象参数相符的元素时，得到它的下标index就调用fastRemove(int index)方法进行删除。而fastRemove(int index)的源码就更加简单了，除了没有范围检查，不需返回元素之外，跟remove(int index)没有任何区别。<br>&#160; &#160; &#160; &#160;再接下来是查和改两个操作，有关查／改操作的一系列代码都很简单。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    rangeCheck(index);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> elementData(index);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">    rangeCheck(index);</div><div class="line"></div><div class="line">    E oldValue = elementData(index);</div><div class="line">    elementData[index] = element;</div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;本质上都是先调用rangeCheck(index)做容器范围检查，接着根据下标从数组中查找／修改元素。<br>&#160; &#160; &#160; &#160;最后再给出一些其它常用操作的源码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> size;</div><div class="line">    <span class="comment">//显然返回容器的size</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</div><div class="line">    <span class="comment">//根据size是否等于0来判断是否为0</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</div><div class="line">    <span class="comment">//调用indexOf(Object o)判断是否包含某特定元素</span></div><div class="line">    <span class="comment">//indexOf(Object o)是查询对象在数组中的位置(下标)。如果不存在，则会返回-1</span></div><div class="line">    <span class="comment">//所以如果该方法返回结果&gt;=0，自然容器就包含某特定元素</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</div><div class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</div><div class="line">                <span class="keyword">return</span> i;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</div><div class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</div><div class="line">                <span class="keyword">return</span> i;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    <span class="comment">//核心思想也就是对数组进行遍历</span></div><div class="line">    <span class="comment">//当遍历到有元素符合我们传入的对象时，就返回该元素的下标值</span></div><div class="line">    <span class="comment">//如果没有符合的元素，则返回-1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</div><div class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</div><div class="line">                <span class="keyword">return</span> i;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</div><div class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</div><div class="line">                <span class="keyword">return</span> i;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    <span class="comment">//与indexOf方法唯一的不同在于，这里选择将数组从后向前进行遍历</span></div><div class="line">    <span class="comment">//所以返回的值就将是元素在数组里最后出现的下标</span></div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="keyword">public</span> Object[] toArray() &#123;</div><div class="line">    <span class="keyword">return</span> Arrays.copyOf(elementData, size);</div><div class="line">    <span class="comment">//通过Arrays.copyOf进行转换，返回一个数组</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</div><div class="line">    <span class="keyword">if</span> (a.length &lt; size)</div><div class="line">        <span class="comment">// Make a new array of a's runtime type, but my contents:</span></div><div class="line">        <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</div><div class="line">    System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</div><div class="line">    <span class="keyword">if</span> (a.length &gt; size)</div><div class="line">        a[size] = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">return</span> a;</div><div class="line">    <span class="comment">//同样的数组拷贝的工作</span></div><div class="line">    <span class="comment">//有所不同的是，这里做的操作是将elementData作为源数组，将其中的元素拷贝到a当中，然后返回a</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line"></div><div class="line">    <span class="comment">// clear to let GC do its work</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</div><div class="line">        elementData[i] = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    size = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 遍历数组，将元素全部设置为null，之后由gc堆负责废弃对象清理</span></div><div class="line">    <span class="comment">//同时将容器size置为0</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;分析完这些代码，基本上ArrayList基本操作就分析完了。但ArrayList的源码远不止这些，仍然有很多源码本博文中没有涉及到。但是从以上的一些分析我们可以看出，实质上，ArrayList的内部实现就是一个数组，只要了解到这一点，理解其它源码就不再是问题。作为这篇博文的完结，博主可以给ArrayList下一个不正式的定义：ArrayList就是一个包装过的，可以自动扩容的，做了边界检查的，增删查找效率比较高的数组。</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2016/12/01/浅析JDK源码之集合框架（六）/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">浅析JDK源码之集合框架（六）</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="浅析JDK源码之集合框架（七）" data-title="浅析JDK源码之集合框架（七）" data-url="http://yoursite.com/2016/12/05/浅析JDK源码之集合框架（七）/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"4c527"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Jason Cheng
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: ''
	}
</script>
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>