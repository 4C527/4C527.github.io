<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>浅析JDK源码之集合框架（七） | Jason Cheng的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="上一篇：浅析JDK源码之集合框架（六）下一篇：浅析JDK源码之集合框架（七补）（Jason Cheng 原创，未经许可不可转载） 
HashMap类源码分析&amp;#160; &amp;#160; &amp;#160; &amp;#160;上一篇我们分析了Map接口的源码，在这一篇中我们就正式开始分析Map体系中最重要，也是广大程序员最常用的一个类：HashMap.">
<meta property="og:type" content="article">
<meta property="og:title" content="浅析JDK源码之集合框架（七）">
<meta property="og:url" content="https://4c527.github.io/2016/12/05/浅析JDK源码之集合框架（七）/index.html">
<meta property="og:site_name" content="Jason Cheng的博客">
<meta property="og:description" content="上一篇：浅析JDK源码之集合框架（六）下一篇：浅析JDK源码之集合框架（七补）（Jason Cheng 原创，未经许可不可转载） 
HashMap类源码分析&amp;#160; &amp;#160; &amp;#160; &amp;#160;上一篇我们分析了Map接口的源码，在这一篇中我们就正式开始分析Map体系中最重要，也是广大程序员最常用的一个类：HashMap.">
<meta property="og:image" content="http://ocpreuqkv.bkt.clouddn.com/blog12/2/1352093418_6990.png">
<meta property="og:image" content="http://ocpreuqkv.bkt.clouddn.com/blog19/1/20160703165543680.png">
<meta property="og:updated_time" content="2016-12-20T07:46:44.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="浅析JDK源码之集合框架（七）">
<meta name="twitter:description" content="上一篇：浅析JDK源码之集合框架（六）下一篇：浅析JDK源码之集合框架（七补）（Jason Cheng 原创，未经许可不可转载） 
HashMap类源码分析&amp;#160; &amp;#160; &amp;#160; &amp;#160;上一篇我们分析了Map接口的源码，在这一篇中我们就正式开始分析Map体系中最重要，也是广大程序员最常用的一个类：HashMap.">
<meta name="twitter:image" content="http://ocpreuqkv.bkt.clouddn.com/blog12/2/1352093418_6990.png">
  
    <link rel="alternative" href="/atom.xml" title="Jason Cheng的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="http://ocpreuqkv.bkt.clouddn.com/logosuolue.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/avatar.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Jason Cheng</a></h1>
		</hgroup>

		
		<p class="header-subtitle">Witness me.Witness me.</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tags/深度学习">深度学习</a></li>
				        
							<li><a href="/tags/leetcode">leetcode</a></li>
				        
							<li><a href="/tags/随笔">随笔</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/JDK源码/" style="font-size: 20px;">JDK源码</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/TensorFlow/" style="font-size: 17.5px;">TensorFlow</a> <a href="/tags/Tree/" style="font-size: 12.5px;">Tree</a> <a href="/tags/leetcode/" style="font-size: 17.5px;">leetcode</a> <a href="/tags/卷积神经网络/" style="font-size: 10px;">卷积神经网络</a> <a href="/tags/数据结构/" style="font-size: 17.5px;">数据结构</a> <a href="/tags/深度学习/" style="font-size: 17.5px;">深度学习</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/链表/" style="font-size: 15px;">链表</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">Witness me.Witness me.</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Jason Cheng</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img lazy-src="null/img/avatar.jpg" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">Jason Cheng</h1>
			</hgroup>
			
			<p class="header-subtitle">Witness me.Witness me.</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/深度学习">深度学习</a></li>
		        
					<li><a href="/tags/leetcode">leetcode</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-浅析JDK源码之集合框架（七）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/12/05/浅析JDK源码之集合框架（七）/" class="article-date">
  	<time datetime="2016-12-05T03:05:44.000Z" itemprop="datePublished">2016-12-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      浅析JDK源码之集合框架（七）
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JDK源码/">JDK源码</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://4c527.github.io/2016/12/01/%E6%B5%85%E6%9E%90JDK%E6%BA%90%E7%A0%81%E4%B9%8B%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%88%E5%85%AD%EF%BC%89/">上一篇：浅析JDK源码之集合框架（六）</a><br><a href="https://4c527.github.io/2016/12/20/%E6%B5%85%E6%9E%90JDK%E6%BA%90%E7%A0%81%E4%B9%8B%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%83%E8%A1%A5%EF%BC%89/">下一篇：浅析JDK源码之集合框架（七补）</a><br>（Jason Cheng 原创，未经许可不可转载） </p>
<h1 id="HashMap类源码分析"><a href="#HashMap类源码分析" class="headerlink" title="HashMap类源码分析"></a>HashMap类源码分析</h1><p>&#160; &#160; &#160; &#160;上一篇我们分析了Map接口的源码，在这一篇中我们就正式开始分析Map体系中最重要，也是广大程序员最常用的一个类：HashMap.<a id="more"></a><br>&#160; &#160; &#160; &#160;相对之前的List体系来说的话，HashMap数据结构的实现要更为复杂一点。但实际上，如果我们了解之后，也就会觉得其实这种结构很清晰。在分析HashMap的源码之前，我们先补充一点关于哈希表的基础知识，让一些不太了解哈希表的读者也能理解（HashMap正是基于这种数据结构来实现的）：<br>&#160; &#160; &#160; &#160;散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。<br>&#160; &#160; &#160; &#160;也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。<br>&#160; &#160; &#160; &#160;这个映射函数叫做散列函数，存放记录的数组就叫做散列表。<br>&#160; &#160; &#160; &#160;给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，我们就称表M为哈希表，函数f(key)为哈希(Hash)函数。<br>&#160; &#160; &#160; &#160;也就是说，我们归纳来说，虽然被命名为哈希表，但实际上，内部的数据结构仍然是基于数组来维护的（这个说法非常笼统，只是为了便于大家理解。实际上，这个“数组”内部的实现机制有多种）。<br>&#160; &#160; &#160; &#160;只是该数组与List对比来说，它不再直接存储值，而是通过将我们存储的对象计算出一个值，这个值就是所谓的哈希值（散列码），也就是上面的概念提到的Key Value（关键码值），然后数组通过维护该关键码值，从而避免了速度缓慢的线性查询，从而提高数据的访问速度。<br>&#160; &#160; &#160; &#160;基础知识补充完了，接下来的这一篇我们就开始分析真正的HashMap源码。（代码基于JDK1.8）<br>&#160; &#160; &#160; &#160;为了让大家对集合框架中的继承体系有一个更直观的认识，这里继续放上集合的结构图：</p>
<p><center><img src="http://ocpreuqkv.bkt.clouddn.com/blog12/2/1352093418_6990.png" width="70%"></center><br>&#160; &#160; &#160; &#160;为了分析过程中思路清晰，我们同样先从该容器类的继承结构说起。打开HashMap的源码，首先看到这样的类声明：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></div><div class="line">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></div></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;可以看到，继承结构上，HashMap继承了AbstractMap类，同时实现了Map<k,v>接口。<br>&#160; &#160; &#160; &#160;好，到了正式的代码部分。首先让我们来看看HashMap的几个重要成员变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></div><div class="line"><span class="comment">//HashMap的初始容量</span></div><div class="line"><span class="comment">//为什么不直接写成16？HashMap的作者是想用这种写法告诉你只能是2的幂</span></div><div class="line"><span class="comment">//小结：HashMap的初始容量是16，而且容量只能是2的幂，每次扩容时都是变成原来的2倍</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</div><div class="line"><span class="comment">//HashMap能允许的最大容量</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</div><div class="line"><span class="comment">//负载因子是指哈希表在多满时扩容的百分比比例</span></div><div class="line"><span class="comment">//当哈希表的数据个数超过负载因子和当前容量的乘积时</span></div><div class="line"><span class="comment">//哈希表要再做一次哈希（重建内部数据结构），哈希表每次扩容为原来的2倍</span></div><div class="line"><span class="comment">//负载因子的默认值是0.75， 它平衡了时间和空间复杂度</span></div><div class="line"><span class="comment">//负载因子越大会降低空间复杂度，但是会增加每次读取／查询的成本</span></div><div class="line"><span class="comment">//默认的负载因子是0.75f， 16*0.75=12</span></div><div class="line"><span class="comment">//即默认的HashMap实例在插入第13个数据时，会扩容为32</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</div><div class="line"><span class="comment">//注这是JDK1.8对HashMap的优化</span></div><div class="line"><span class="comment">//哈希碰撞后的链表上达到8个节点时要将链表重构为红黑树</span></div><div class="line"><span class="comment">//查询的时间复杂度变为O(logN)</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</div><div class="line"></div><div class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</div><div class="line"><span class="comment">//HashMap的桶</span></div><div class="line"><span class="comment">//如果没有哈希碰撞，HashMap就是数组，数组的查询时间复杂度是O(1)，所以HashMap理想时间复杂度是O(1)</span></div><div class="line"><span class="comment">//如果所有数据都在同一个下标位置，即N个数据组成链表，时间复杂度为O(n)，所以HashMap的最坏时间复杂度为O(n)</span></div><div class="line"><span class="comment">//如果链表达到8个元素时重构为红黑树，而红黑树的查询时间复杂度为O(logN), 所以这时HashMap的时间复杂度为O(logN)</span></div><div class="line"></div><div class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</div><div class="line"><span class="comment">//HashMap所有的值，因为用了Set， 所以HashMap不会有key、value都相同的entry</span></div><div class="line"></div><div class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</div><div class="line"><span class="comment">//存放元素的个数 </span></div><div class="line"></div><div class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</div><div class="line"><span class="comment">//被修改的次数</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> threshold;</div><div class="line"><span class="comment">//临界值 当实际大小(容量*填充比)超过临界值时，会进行扩容</span></div><div class="line"></div><div class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</div><div class="line"><span class="comment">//负载因子</span></div></pre></td></tr></table></figure></k,v></p>
<p>&#160; &#160; &#160; &#160;分析完了HashMap的几个重要成员变量，接下来我们再来分析HashMap中几个重要的数据结构，分析完后，我们对HashMap的内部机制就有了一个基础的理解，首先是HashMap中链表的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">//Node是单向链表，它实现了Map.Entry接口  </span></div><div class="line">    </div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</div><div class="line">    <span class="keyword">final</span> K key;</div><div class="line">    V value;</div><div class="line">    Node&lt;K,V&gt; next;</div><div class="line">   </div><div class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</div><div class="line">        <span class="keyword">this</span>.hash = hash;</div><div class="line">        <span class="keyword">this</span>.key = key;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">        <span class="keyword">this</span>.next = next;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//构造函数，传入参数为：hash值，键，值，next节点 </span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</div><div class="line">        V oldValue = value;</div><div class="line">        value = newValue;</div><div class="line">        <span class="keyword">return</span> oldValue;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//重设置节点值，返回旧值</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</div><div class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</div><div class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</div><div class="line">                Objects.equals(value, e.getValue()))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//判断两个node是否相等,若key和value都相等，返回true</span></div><div class="line">    <span class="comment">//可以与自身比较为true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;接着是HashMap中红黑树的源码：     </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></div><div class="line">    <span class="comment">//红黑树父节点</span></div><div class="line">    </div><div class="line">    TreeNode&lt;K,V&gt; left;</div><div class="line">    <span class="comment">//左节点</span></div><div class="line">    </div><div class="line">    TreeNode&lt;K,V&gt; right;</div><div class="line">    <span class="comment">//右节点</span></div><div class="line">    </div><div class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></div><div class="line">    <span class="keyword">boolean</span> red;</div><div class="line">    <span class="comment">//颜色属性</span></div><div class="line">    </div><div class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</div><div class="line">        <span class="keyword">super</span>(hash, key, val, next);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns root of tree containing this node.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="keyword">this</span>, p;;) &#123;</div><div class="line">            <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">return</span> r;</div><div class="line">            r = p;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//返回当前节点的根节点</span></div><div class="line">    </div><div class="line">    <span class="comment">//TreeNode类还有其他很多函数，这里略去</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;接下来是HashMap内部用于存储链表／红黑树的数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</div><div class="line"><span class="comment">//存储（位桶）的数组</span></div></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;分析完了以上3个数据结构，只要有一点数据结构基础的人，都可以大致联想到HashMap的实现了。首先有一个每个元素都是链表（这一点描述并不十分准确）的数组，当添加一个元素（key-value）时，就首先计算元素key的hash值，以此确定插入数组中的位置，但是可能存在同一hash值的元素已经被放在数组同一位置了，这时就添加到同一hash值的元素的后面，他们在数组的同一位置，但是形成了链表，所以说数组存放的是链表。而当链表长度太长时，链表就转换为红黑树，这是为了效率上的考虑。<br>&#160; &#160; &#160; &#160;在之前的版本JDK1.6中，HashMap采用位桶+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。所以在JDK1.8中引入了红黑树，HashMap采用位桶+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。<br>&#160; &#160; &#160; &#160;HashMap的数据结构图解如下图所示：</p>
<p><center><img src="http://ocpreuqkv.bkt.clouddn.com/blog19/1/20160703165543680.png" width="70%"></center><br>&#160; &#160; &#160; &#160;接下来是Hashmap的构造器部分:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</div><div class="line">                                           initialCapacity);</div><div class="line">    <span class="comment">//指定的初始容量非负  </span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">        initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">    <span class="comment">//如果指定的初始容量大于最大容量,置为最大容量  </span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</div><div class="line">                                           loadFactor);</div><div class="line">    <span class="comment">//保证填充比为正且为一个float数</span></div><div class="line">                                            </div><div class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">    <span class="comment">//初始化负载因子</span></div><div class="line">    </div><div class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</div><div class="line">    <span class="comment">//初始化临界值threshold</span></div><div class="line">    <span class="comment">//tableSizeFor(initialCapacity)函数保证了threshold是一个略大于</span></div><div class="line">    <span class="comment">//initialCapacity的2的幂</span></div><div class="line">    <span class="comment">//具体算法见源码，此处不再详解</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</div><div class="line">    <span class="comment">//第二个构造函数，以默认的负载因子0.75和传入的初始容量构造HashMap</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></div><div class="line">    <span class="comment">//第三个构造函数，除了初始化负载因子外其他全部设置为缺省值</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</div><div class="line">    putMapEntries(m, <span class="keyword">false</span>);</div><div class="line">    <span class="comment">//第四个构造函数，用Map m的元素初始化HashMap</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;看完了构造器部分，接下来是HashMap常见操作，首先是HashMap的扩容机制：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;  </div><div class="line">    <span class="comment">//可用来初始化HashMap大小，或重新调整HashMap大小，变为原来2倍大小 </span></div><div class="line">    Node&lt;K,V&gt;[] oldTab = table;  </div><div class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;  </div><div class="line">    <span class="keyword">int</span> oldThr = threshold;  </div><div class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;  </div><div class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;  </div><div class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</div><div class="line">    <span class="comment">//超过1 &lt;&lt; 30大小，则无法扩容只能改变阈值  </span></div><div class="line">            threshold = Integer.MAX_VALUE;  </div><div class="line">            <span class="keyword">return</span> oldTab;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;  </div><div class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</div><div class="line">    <span class="comment">//新的容量为旧的2倍，最小也是16  </span></div><div class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; </div><div class="line">    <span class="comment">//扩容阈值加倍 </span></div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)   </div><div class="line">        newCap = oldThr;</div><div class="line">    <span class="comment">//oldCap = 0,oldThr &gt; 0</span></div><div class="line">    <span class="comment">//此时newThr = 0   </span></div><div class="line">    <span class="keyword">else</span> &#123;               </div><div class="line">    <span class="comment">//oldCap = 0,oldThr = 0 </span></div><div class="line">    <span class="comment">//相当于使用默认填充比和初始容量进行初始化  </span></div><div class="line">        newCap = DEFAULT_INITIAL_CAPACITY;  </div><div class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);  </div><div class="line">    &#125;         </div><div class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;  </div><div class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;  </div><div class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?  </div><div class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);  </div><div class="line">    &#125;  </div><div class="line">    threshold = newThr;  </div><div class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)  </div><div class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];  </div><div class="line">    <span class="comment">//原先的数组中保存的元素复制到新的数组中，分红黑树和链表讨论  </span></div><div class="line">    table = newTab;  </div><div class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;  </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;  </div><div class="line">            Node&lt;K,V&gt; e;  </div><div class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;  </div><div class="line">                oldTab[j] = <span class="keyword">null</span>;  </div><div class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)  </div><div class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;  </div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)  </div><div class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);  </div><div class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order  </span></div><div class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;  </div><div class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;  </div><div class="line">                    Node&lt;K,V&gt; next;  </div><div class="line">                    do &#123;  </div><div class="line">                        next = e.next;  </div><div class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;  </div><div class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)  </div><div class="line">                                loHead = e;  </div><div class="line">                            <span class="keyword">else</span>  </div><div class="line">                                loTail.next = e;  </div><div class="line">                            loTail = e;  </div><div class="line">                        &#125;  </div><div class="line">                        <span class="keyword">else</span> &#123;  </div><div class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)  </div><div class="line">                                hiHead = e;  </div><div class="line">                            <span class="keyword">else</span>  </div><div class="line">                                hiTail.next = e;  </div><div class="line">                            hiTail = e;  </div><div class="line">                        &#125;  </div><div class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);  </div><div class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;  </div><div class="line">                        loTail.next = <span class="keyword">null</span>;  </div><div class="line">                        newTab[j] = loHead;  </div><div class="line">                    &#125;  </div><div class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;  </div><div class="line">                        hiTail.next = <span class="keyword">null</span>;  </div><div class="line">                        newTab[j + oldCap] = hiHead;  </div><div class="line">                    &#125;  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> newTab;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;接下来是HashMap的2个常用操作，put和get。先是有关于put操作的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line">               <span class="keyword">boolean</span> evict) &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</div><div class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</div><div class="line">        n = (tab = resize()).length;</div><div class="line">    <span class="comment">//如果tab为空或长度为0，则分配内存resize()</span></div><div class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</div><div class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">    <span class="comment">//(n - 1) &amp; hash找到put位置，如果为空,则直接put</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        Node&lt;K,V&gt; e; K k;</div><div class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">        <span class="comment">//如果第一节节点与插入节点的hash值相同，且key值与插入key相同</span></div><div class="line">        <span class="comment">//直接把第一个节点p赋给e</span></div><div class="line">            e = p;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</div><div class="line">        <span class="comment">//属于红黑树处理冲突 </span></div><div class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//属于链表处理冲突 </span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line">            <span class="comment">//p第一次指向表头,以后依次后移  </span></div><div class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">//e为空，表示已到表尾也没有找到key值相同节点，则新建节点 </span></div><div class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></div><div class="line">                        treeifyBin(tab, hash);</div><div class="line">                        <span class="comment">//新增节点后如果节点个数到达阈值，则将链表转换为红黑树</span></div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                p = e;</div><div class="line">                <span class="comment">//如果找到key值相同节点，则更新p指向下一个节点</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></div><div class="line">            V oldValue = e.value;</div><div class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line">                e.value = value;</div><div class="line">            afterNodeAccess(e);</div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//更新hash值和key值均相同的节点Value值</span></div><div class="line">    &#125;</div><div class="line">    ++modCount;</div><div class="line">    <span class="keyword">if</span> (++size &gt; threshold)</div><div class="line">        resize();</div><div class="line">    afterNodeInsertion(evict);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;接着是get操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt; e;</div><div class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</div><div class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">//hash &amp; (length-1)得到对象的保存位</span></div><div class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></div><div class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            <span class="keyword">return</span> first;</div><div class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</div><div class="line">                <span class="comment">//如果第一个节点是TreeNode,说明采用的是数组+红黑树结构处理冲突</span></div><div class="line">            do &#123;</div><div class="line">            <span class="comment">//如果是链表结构，则遍历链表中所有节点，找到key，则返回节点e</span></div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="keyword">return</span> e;</div><div class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    <span class="comment">//如果没有任何节点包含key，则返回null</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;分析完这些代码，基本上我们对于HashMap就有了一个大概的了解，但是如果读者打开HashMap的源码，就会发现，在这篇博客中详细分析的代码量只占30%不到，HashMap中还有大量有关于红黑树的代码，包括链表和红黑树的转换和红黑树本身的一些操作，包括红黑树的插入，删除，左旋，右旋等等。但博客中分析的这些代码对于理解HashMap是一种怎么样的集合框架已经足够了。对红黑树以及有兴趣的读者可以自行查看HashMap源码。</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/12/20/浅析JDK源码之集合框架（七补）/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          浅析JDK源码之集合框架（七补）
        
      </div>
    </a>
  
  
    <a href="/2016/12/01/浅析JDK源码之集合框架（六）/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">浅析JDK源码之集合框架（六）</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="浅析JDK源码之集合框架（七）" data-title="浅析JDK源码之集合框架（七）" data-url="https://4c527.github.io/2016/12/05/浅析JDK源码之集合框架（七）/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"4c527"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 Jason Cheng
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: ''
	}
</script>
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
  </div>
</body>
</html>